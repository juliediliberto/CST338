/*
	Matthew Bichay
	Julia Diliberto
	Vanessa Ulloa
	James O'Dea
	CST 338 - Module 5
	Assignment #5

	
	Phase 2:
		Encapsulate the Card icons in a class GUICard
		Create a CardTable Class

*/

import java.awt.*;
import javax.swing.*;
import javax.swing.border.*;

public class Assign5P2 
{
	// VARIABLES
	static int NUM_CARDS_PER_HAND = 7;
	static int NUM_PLAYERS = 2;
	
	// "Labels" = card
	static JLabel[] computerLabels = new JLabel[NUM_CARDS_PER_HAND];
	static JLabel[] humanLabels = new JLabel[NUM_CARDS_PER_HAND];
	static JLabel[] playedCardLabels = new JLabel[NUM_CARDS_PER_HAND];
	static JLabel[] playLabelText = new JLabel[NUM_CARDS_PER_HAND];
	
	public static void main(String[] args) 
	{
		int k;
		int tempIcon;
		
		// establish ain frame in which program will run
		CardTable myCardTable = new CardTable("CardTable",NUM_CARDS_PER_HAND,NUM_PLAYERS);
		
		/*
			attributes of the CardTable which is a JFrame object, 
			Panels will be created from the GridLayout object
			and then the labels on that.
		*/
		myCardTable.setSize(800,600);
		myCardTable.setLocationRelativeTo(null);
		myCardTable.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		// show everything to the user
		myCardTable.setVisible(true);
		
		/*
			CREATE LABELS
			labels (Cards) are created and added to the appropriate arrays
			humanLabels = users cards
			computerLabels = computers cards (will only see the back)
		*/
		for(k = 0 ; k < NUM_CARDS_PER_HAND ; k++)
			humanLabels[k] = new JLabel(GUICard.getIcon(generateRandomCard()));

		for(k = 0 ; k < NUM_CARDS_PER_HAND ; k++)
			computerLabels[k] = new JLabel(GUICard.getBackCardIcon());

		/*
			ADD LABELS TO PANELS
			added to pnlPlayArea (the middle panel)
		*/
		for(k = 0 ; k < NUM_CARDS_PER_HAND ; k++)
		{
			myCardTable.pnlComputerHand.add(computerLabels[k]);
			myCardTable.pnlHumanHand.add(humanLabels[k]);
		}
		
		/* 
			ADD 2 RANDMOM CARDS IN PLAY REGION (SIMULATING A COMPUTER/HUMAN PLAY)
			Add Cards to to the Play Region (first card played)
			Cards generated by generateRandomCard() are added to played cards so they cannot be used again. 
			the played cards will be on a grid layout
		*/
		for(k = 0 ; k < NUM_PLAYERS ; k++)
			playedCardLabels[k] = new JLabel(GUICard.getIcon(generateRandomCard()));
		
		playLabelText[0] = new JLabel("Computer",0);
		playLabelText[1] = new JLabel("You",0);
		
		// create the Gridlayout
		myCardTable.pnlPlayArea.add(playLabelText[0], JLabel.CENTER);
		myCardTable.pnlPlayArea.add(playLabelText[1], JLabel.CENTER);
		myCardTable.pnlPlayArea.add(playedCardLabels[0],JLabel.CENTER);
		myCardTable.pnlPlayArea.add(playedCardLabels[1],JLabel.CENTER);
		
		// show everything to the usre
		myCardTable.setVisible(true);
		
	}	// end main
	
	/*
		generateRandomCard()
		will generate a random card (new Card object)
		will use Math.random to generate a random suit and value
	*/
	public static Card generateRandomCard()
	{
		int randomSuit, randomValue;

		randomSuit = (int)(Math.random() * 3);
		randomValue = (int)(Math.random() * 14);
		
		//System.out.println("gnr - Suit: " + randomSuit + " , value: " + randomValue);
		Card newCard = new Card(intToValue(randomValue),intToSuit(randomSuit));
		//System.out.println("gnr - Card: " + newCard.getValue() + ", " + newCard.getSuit());
		return newCard;
	}

	/*
		intToValue(int)
		takes the random int value and returns a value
		from the enum in the Card class (Card.Value)
	*/
	public static Card.Value intToValue(int value)
	{
		// check for valid value entry, if not return default (AS)
		// Value enum has 14 values
		Card.Value[] cValues = {
				Card.Value.ACE,
				Card.Value.TWO,
				Card.Value.THREE,
				Card.Value.FOUR,
				Card.Value.FIVE,
				Card.Value.SIX,
				Card.Value.SEVEN,
				Card.Value.EIGHT,
				Card.Value.NINE,
				Card.Value.TEN,
				Card.Value.JACK,
				Card.Value.QUEEN,
				Card.Value.KING,
				Card.Value.JOKER
		};
		
		// find a way to retunr specific value of enum
		if(value <= 0 || value > 13)
			return Card.Value.ACE;
		else
			// return appropriate value
			return cValues[value - 1];
	}
	

	/*
		intToSuit(int)
		takes random int value adn returns a Suit
		from the enum in the Card Class (Card.Suit)
	*/
	public static Card.Suit intToSuit(int value)
	{
		// check for valid entry, if not return default (AS)
		// Suit enum has 4 values
		Card.Suit[] cSuits = {
				Card.Suit.SPADES,
				Card.Suit.CLUBS,
				Card.Suit.DIAMONDS,
				Card.Suit.HEARTS
		};
		
		if(value <= 0 || value > 3)
			return Card.Suit.SPADES;
		else
			return cSuits[value];
	}

}	//end class

*************************************************************************************
/*
 	Hand Class from Assignment #3
 	added methods
*/

public class Hand 
{
	//	constants
	public static final int MAX_CARDS = 52;
	
	//	private variables
	private Card[] myCards;
	public int numCards;
	
	//	Constructor
	Hand(){
		// create a Hand of MAX_CARDS
		myCards = new Card[MAX_CARDS];
		
		//	reset hand by default
		resetHand();
	}
	
	//	methods
	
	public void resetHand(){
		
		// loop through up to MAX CARDS and null every value
		for(int x = 0 ; x < MAX_CARDS ; x++)
		{
			myCards[x] = null;
		}
		
		//reset numCards value
		numCards = 0;	
	}
	
	public boolean takeCard(Card card){
		//	adds a Card to the Hand
		
		//	make sure that numCards does not exceed MAX_CARDS
		if(numCards < MAX_CARDS){
			myCards[numCards] = card;
			numCards++;
			return true;
		}
		return false;
	}

	public Card playCard()
	{
		//	to "play" a card it is removed from the hand
		Card playingCard = myCards[numCards];
		myCards[numCards] = null;
		numCards--;
		return playingCard;
	}

	public String toString(){
		//	display hand
		//	if hand is empty, then show empty  space, otherwise show hand
		
		if(numCards == 0)
		{
			return "My Hand:[]";
		}
		
		String myHand = "My Hand: [ ";
		
		for(int x = 0; x <= numCards ; x++)
		{
			myHand += ", " + myCards[x].toString();
		}
		return myHand + " ]";
	}
	
	public int getNumCards()
	{
		return numCards;
	}
	
	public Card inspectCard(int k)
	{
		//inspect cards to check for legal values
		
		if(k >= this.numCards || k < 0)
		{
			return new Card('Z',Card.Suit.SPADES);
		}
		else
		{	
			return myCards[k].clone();
		}
	}
	
	// ADDED METHODS
	
	public void sort()
	{
		//uses Arraysort from Card class
		Card.arraySort(myCards, numCards+1);
	}
	
	
}//	end class

**********************************************************************************************
/*
	public class GUICard
	class that manages the reading and the building of the card image Icons. 
	This class is used to produce an image icon where the cilent needs one. 
*/

import java.awt.*;
import javax.swing.*;
import javax.swing.JFrame;
import javax.swing.border.*;

public class GUICard
{
    // VARIABLES
    // 14 - different card values, 4 - number of suits
    private static Icon[][] iconCards = new ImageIcon[14][4];
    // iconBack is the back of the card image
    private static Icon iconBack;
    static boolean iconsLoaded = false;
    static String suit;
    static String cValue;

    // METHODS
    /*
		loadCardIcons()
		stores icons in a 2-D array
		see Phase 1
		Check iconsLoaded to determine whether to call method
	*/
    static void loadCardIcons()
    {
        if (iconCards.length <= 0) {
            for (int x = 0; x < 4; x++) {
                for (int y = 0; y <= 13; y++) {
                    cValue = intToCardValue(y);
                    suit = intToCardSuit(x);
                    iconCards[y][x] = new ImageIcon("images/" + cValue + suit + ".gif");
                }

            }
        }

    }

    static String intToCardValue(int k)
    {
        char[] cardValues = {'2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A', 'X'};

        if (k >= 0 && k <= 13)
            return Character.toString(cardValues[k]);
        else {
            System.out.println("invalid Card value");
            return Character.toString(cardValues[0]);
        }

    }

    /*
        turnIntIntoCardSuit(int)
        String method that takes 0 - 3 and returns an appropriate suit.
    */
    static String intToCardSuit(int j)
    {
        char[] suitValues = {'C', 'D', 'H', 'S'};

        if (j >= 0 && j <= 3)
            return Character.toString(suitValues[j]);
        else {
            System.out.println("invalid suit value");
            return Character.toString(suitValues[0]);
        }

    }

    /*
        getIcon(Card)
        takes Card object from the client, returns the Icon for that Card.
    */
    static public Icon getIcon(Card card)
    {
        return iconCards[valueAsInt(card)][suitAsInt(card)];
    }

    /*
        getBackCardIcon()

    */
    static public Icon getBackCardIcon()
    {
        return new ImageIcon("images/BK.gif");
    }

    /*
     valueAsInt(card)
     used to return value to get filename and picture
    */
    static private int valueAsInt(Card card)
    {
        return card.getValue().asInt() - 2;
    }


    /*
        suitAsInt(card)
        used to return value to get filename and picture
    */
    static private int suitAsInt(Card card)
    {
        return card.getSuit().asInt() - 2;
    }
}
***********************************************************************************
/*
   Deck class from Assignment #3
   added methods and Joker
   add methods for adding and removing cards from the deck as well as as a sort method
*/
import java.util.Collections;
import java.util.Arrays;

public class Deck 
{
   //constants
   public static final int MAX_PACK = 6;
   public static final int MAX_CARDS_IN_PACK = 56;
   public static final int MAX_CARDS = MAX_CARDS_IN_PACK * MAX_PACK;
   
   //private variables
   private static Card[] masterPack;   //contains 52 cards, no duplicates
   private Card[] cards;
   private int topCard;
   private int numPacks;
   
   //variables
   
   
   //constructors
   Deck()
   {
      //default constructor will build 1 pack
      Deck.allocateMasterPack();
    //  this.init(1);
   }
   
   Deck(int numPacks)
   {
      //populates arrays and assigns values
      //check to see if max packs has been assigned
      Deck.allocateMasterPack();
      
      if (numPacks > MAX_PACK)
         init(MAX_PACK);
      else
         init(numPacks);
   }
   
   //public methods
   
   public void init(int numPacks) {
      //create an array from numPacks * packs in a deck
      //add cards to the array until everything is filled
      //default: unshuffled
      
      cards = new Card[MAX_CARDS_IN_PACK * numPacks];
      
      for(int x = 0; x < cards.length ; ++x){//changed from cards.length -1
         cards[x] = Deck.masterPack[MAX_CARDS_IN_PACK%56];
      }
      
      // set the top card
      topCard = MAX_CARDS_IN_PACK * numPacks -1;   //last entry in the array
      
   }
   
   public void shuffle()
   {
      //shuffles the array
      Collections.shuffle(Arrays.asList(cards));
   }
   
   public Card dealCard()
   {
      //removes the top card from the deck (array) and displays it
      //check for empty deck
      
      if(topCard < 0)
         return new Card('Z',Card.Suit.HEARTS);
      else
      {
         Card tCard = cards[topCard].clone();
         cards[topCard] = null;
         topCard--;
         return tCard;
      }
   }
   
   public int getTopCard()
   {
      return topCard;
   }
   
   public Card inspectCard(int k)
   {
      if(k >= topCard || k < 0)
      {
         return new Card('Z',Card.Suit.SPADES);
      }
      else
      {  
         return this.cards[k].clone();
      }
   }
   
   //private methods
   
   private static void allocateMasterPack()
   {
      //called by constructor
      //and only called once, if it is not null
 
      if (Deck.masterPack == null)
      {
         Deck.masterPack = new Card[MAX_CARDS_IN_PACK];
      }
      int i = 0;
         for(Card.Suit suit : Card.Suit.values())
         {
            for(Card.Value value : Card.Value.values())
            {
               Deck.masterPack[i++] = new Card(value,suit);
            }
         }
 
   }
   
   // ADDED METHODS
   
   boolean addCard(Card card)
   {
      if (topCard+1 == cards.length)
         return false;
      topCard++;
      cards[topCard] = card;
      return true;
   }
   
   boolean removeCard(Card card) {
      for (int i = 0; i <= topCard; ++i)
         if (cards[i].equals(this)) {
            cards[i] = cards[topCard];
            cards[topCard] = null;
            return true;
         }
      return false;
   }
   
   // call sort method in the card class
   void sort(){
      Card.arraySort(cards, getNumCards()+1);
   }
   
   int getNumCards(){
      return topCard;
   }
}

**************************************************************************************
import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
/*
class sets up a jPanel for display of game play
*/
public class CardTable extends JFrame
{ 
   static final int WIDTH = 1000;
   static final int HEIGHT = 660;
   static int MAX_CARDS_PER_HAND = 56;
   static int MAX_PLAYERS = 2;
   private int numCardsPerHand;
   private int numPlayers;

   public JPanel pnlComputerHand, pnlHumanHand, pnlPlayArea, pnlControl;
   
   public CardTable(String title, int numCardsPerHand,int numPlayers)
   {
      
      
      //construct a window to display gameplay
      super(title);
      numCardsPerHand = this.numCardsPerHand;
      numPlayers=this.numPlayers;
      setSize(WIDTH, HEIGHT);
      setLocationRelativeTo(null);
      setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
      setLayout(new BorderLayout());
      TitledBorder computerTitle;
      computerTitle = BorderFactory.createTitledBorder("Computer");
      TitledBorder playAreaTitle;
      playAreaTitle = BorderFactory.createTitledBorder("Play Area");
      TitledBorder humanTitle;
      humanTitle = BorderFactory.createTitledBorder("You");

     
 //Design computer hand panel  
      FlowLayout layout = new FlowLayout(FlowLayout.CENTER);
      pnlComputerHand = new JPanel();  
      pnlComputerHand.setLayout(layout);
      pnlComputerHand.setBackground(Color.cyan);
      pnlComputerHand.setBorder(computerTitle);
      
      for(int k = 0 ; k < numCardsPerHand ; k++)
      {
   //      pnlComputerHand.add(computer[k]);
      }
      add(pnlComputerHand, BorderLayout.PAGE_START); 
      
         
 
//Design play area panel
      pnlPlayArea = new JPanel();
      pnlPlayArea.setLayout(new GridLayout(2,2,0,0));
      //JLabel compPlay = new JLabel();
      //JLabel humanPlay = new JLabel();
      //JLabel compTag = new JLabel("Computer");
      //JLabel humanTag = new JLabel("You");
      //pnlPlayArea.add(compPlay);
      //pnlPlayArea.add(humanPlay);
      //pnlPlayArea.add(compTag,JLabel.CENTER);
      //pnlPlayArea.add(humanTag,JLabel.CENTER);
      pnlPlayArea.setBackground(Color.GRAY);
      pnlPlayArea.setBorder(playAreaTitle);
      add(pnlPlayArea, BorderLayout.CENTER);
      
//Design human hand panel
      pnlHumanHand = new JPanel();
      pnlHumanHand.setLayout(layout);
      pnlHumanHand.setBackground(Color.GREEN);
      pnlHumanHand.setBorder(humanTitle);
      for(int k = 0 ; k < numCardsPerHand ; k++)
      {
   //      pnlHumanHand.add(computer[k]); What is this array called?
      }
      add(pnlHumanHand,BorderLayout.SOUTH);

      
  /*    
//Design control and game data panel
      pnlControl = new JPanel();
      pnlControl.setLayout(layout);
      pnlControl.setBackground(Color.GRAY);
      JButton endButton = new JButton ("Click to end game.");
      endButton.setBackground(Color.cyan);
      endButton.addActionListener (new EndingListener());
      pnlControl.add (endButton);    
      add(pnlControl,BorderLayout.PAGE_END);
      */
   }
   
   public int getNumCardsPerHand()
   {
      if (this!=null)
         return this.numCardsPerHand;
      else
         return -1;
   }
   
   public int getNumPlayers()
   {
      if (this!=null)
         return this.numPlayers;
      else 
         return -1;
   }
}
********************************************************************************************
import java.util.HashMap;
import java.util.Map;
/*
	Card class from Assignment #3
	+ Added Joker suit and value
	+ added methods for card comparison
*/

public class Card 
{
	enum Suit {
	    SPADES      ("Spades"),
	    HEARTS      ("Hearts"),
	    DIAMONDS    ("Diamonds"),
	    CLUBS       ("Clubs");

	    // Did this to add a toString and give the enum a value.
	    private final String suit;
	    private Suit(final String newSuit) {suit = newSuit;}

	    public String asString() {return suit;}

	    public int asInt() {
	    	switch(suit) {
	    		case "Spades": return 0;
	    		case "Hearts": return 1;
	    		case "Diamonds": return 2;
	    		default: return 3;
	    	}
	    }

	}

	enum Value {
	    TWO     ('2'),
	    THREE   ('3'),
	    FOUR    ('4'),
	    FIVE    ('5'),
	    SIX     ('6'),
	    SEVEN   ('7'),
	    EIGHT   ('8'),
	    NINE    ('9'),
	    TEN     ('T'),
	    JACK    ('J'),
	    QUEEN   ('Q'),
	    KING    ('K'),
	    ACE     ('A'),
	    JOKER   ('X');

	    // Did all this below to add a toString and give all the enum elements
	    // a value, this can help for playing games with numbers and printin
	    // strings.
	    private final char value;
	   	private static Map<Character, Value> valueMap;

	   	private static void initializeMap() {
	   		valueMap =  new HashMap<Character, Value>();
	   		for (Value v : Value.values()) {
	   			valueMap.put(v.value, v);
	   		}
	   	}



	    private Value(final char newValue) { value = newValue; }


	    public int asInt() { 
	    	switch(value) {
	    		case 'T': return 10;
	    		case 'J': return 11;
	    		case 'Q': return 12;
	    		case 'K': return 13;
	    		case 'A': return 14;
	    		case 'X': return 15;
	    		default: return Character.getNumericValue(value);
	    	}

	    }

	    public char asChar() { return value; }


	    public static Value fromChar(char c){
	    	if (valueMap == null)
	    		initializeMap();
	    	Value value = valueMap.get(c);
	    	if (valueMap.containsKey(c))
	    		return valueMap.get(c);
	    	return null;
	    }
	}
	
	
	//	variables
	private Value value;
	private Suit suit;
	private Boolean errorFlag;
	
	//	constructors
	
	
	Card(char value, Suit suit)
	{
		this.set(value,suit);		
	}
	
	Card()
	{
		set('A', Suit.SPADES);
	}	
	
	Card(Value value, Suit suit){
		this.set(value.asChar(),suit);		
	}
	
	@Override
	public Card clone()	{ return new Card(this.value.asChar(),this.suit); }
	
	
	//	methods
	 public String toString()
	 {
		if(getErrorFlag())
			return "** illegal card entry **";
		return getValue().asChar() + " of " + getSuit().asString();
	}
	 
	 public boolean set(char value, Suit suit) {
		 this.value = Value.fromChar(Character.toUpperCase(value));
		 if (this.value == null){
		 	this.errorFlag = true;
		 	return false;
		 }
		 this.suit = suit;
		 this.errorFlag = false;
		 return true;
	 
	 }
	 
	 public Suit getSuit(){ return this.suit; }
	 
	 public Value getValue(){ return this.value; }
	 
	 public boolean getErrorFlag(){	return this.errorFlag; }


	public static void arraySort(Card[] cards,int arraySize)
	 {
		 Boolean itsGoTime = true;
		 Card temp;

		 //At best, this is an O(n) sorting method...
		 //At worst, its an O(n^2)
		 while (itsGoTime) {
		 	itsGoTime = false;
		 	for (int i = 0; i < arraySize-1; ++i) {
		 		if (cards[i].getValue().asInt() > cards[i+1].getValue().asInt()) {
		 			temp = cards[i];
		 			cards[i] = cards[i+1];
		 			cards[i+1] = temp;
		 			itsGoTime = true;
		 		}
		 	}
		 }

	 }

	 public Boolean equals(Card card) {
	 	if (card.getValue().asInt() == this.value.asInt()
	 		&& card.getSuit().asString().equals(this.suit.asString()))
	 		return true;
	 	return false;
	 }
	 
}//	end class
*******************************************************************************************
